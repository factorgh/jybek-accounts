"use strict";exports.id=9962,exports.ids=[9962],exports.modules={9962:(t,e,n)=>{n.d(e,{LedgerService:()=>o});var a=n(8013),i=n(777),r=n(5200);class o{static getDb(){return i.default.then(t=>t.db("jybek_accounts"))}static async postJournalEntry(t,e,n,o,c,s){let d=await this.getDb(),u=i.default.then(t=>t.startSession());try{let i=await u;await i.withTransaction(async()=>{let u=c.reduce((t,e)=>t+e.debitAmount,0),l=c.reduce((t,e)=>t+e.creditAmount,0);if(u!==l)throw Error(`Transaction does not balance. Debits: ${u}, Credits: ${l}`);if(0===u)throw Error("Transaction must have at least one non-zero amount.");for(let e of c)if(!await d.collection("accounts").findOne({_id:new a.ObjectId(e.accountId),businessId:t,isActive:!0}))throw Error(`Account with ID ${e.accountId} not found or inactive.`);let m=await this.generateTransactionNumber(d,t),p={businessId:t,transactionNumber:m,transactionDate:e,description:n,reference:o,type:r.iU.ManualJournal,isReversed:!1,createdByUserId:s,createdAt:new Date,updatedAt:new Date},w=(await d.collection("transactions").insertOne(p,{session:i})).insertedId.toString(),b=c.map(t=>({transactionId:w,accountId:t.accountId,debitAmount:t.debitAmount,creditAmount:t.creditAmount,description:t.description,createdAt:new Date}));await d.collection("transactionLines").insertMany(b,{session:i}),await this.updateAccountBalances(d,t,b,i)});let l=await d.collection("transactions").findOne({businessId:t,transactionNumber:(await this.generateTransactionNumber(d,t)).replace(/\d+$/,String(parseInt((await this.generateTransactionNumber(d,t)).split("-").pop()||"0")-1))});if(!l)throw Error("Failed to retrieve created transaction");return l}catch(t){throw t}}static async postIncome(t,e,n,a,i,r,o,c){if(a<=0)throw Error("Income amount must be greater than zero.");let s=[{accountId:n,debitAmount:a,creditAmount:0,description:"Income received"},{accountId:e,debitAmount:0,creditAmount:a,description:r}];return await this.postJournalEntry(t,i,r,o,s,c)}static async postExpense(t,e,n,a,i,r,o,c){if(a<=0)throw Error("Expense amount must be greater than zero.");let s=[{accountId:e,debitAmount:a,creditAmount:0,description:r},{accountId:n,debitAmount:0,creditAmount:a,description:"Expense paid"}];return await this.postJournalEntry(t,i,r,o,s,c)}static async reverseTransaction(t,e,n){let i=await this.getDb(),r=await i.collection("transactions").findOne({_id:new a.ObjectId(t)});if(!r)throw Error(`Transaction with ID ${t} not found.`);if(r.isReversed)throw Error("Transaction is already reversed.");let o=(await i.collection("transactionLines").find({transactionId:t}).toArray()).map(t=>({accountId:t.accountId,debitAmount:t.creditAmount,creditAmount:t.debitAmount,description:`Reversal: ${t.description}`})),c=await this.postJournalEntry(r.businessId,new Date,`Reversal: ${r.description} - ${e}`,`REV-${r.transactionNumber}`,o,n);return await i.collection("transactions").updateOne({_id:new a.ObjectId(t)},{$set:{isReversed:!0,reversedByTransactionId:c._id,updatedAt:new Date}}),c}static async generateTransactionNumber(t,e){let n=new Date().getFullYear(),a=`JE-${n}-`,i=await t.collection("transactions").find({businessId:e,transactionNumber:{$regex:`^${a}`}}).sort({transactionNumber:-1}).limit(1).toArray(),r=1;return i.length>0&&(r=parseInt(i[0].transactionNumber.split("-").pop()||"0")+1),`${a}${r.toString().padStart(6,"0")}`}static async updateAccountBalances(t,e,n,i){for(let o of n){let n=await t.collection("accounts").findOne({_id:new a.ObjectId(o.accountId),businessId:e});if(!n)continue;let c=0;c=n.type===r.Qm.Asset||n.type===r.Qm.Expense?o.debitAmount-o.creditAmount:o.creditAmount-o.debitAmount,await t.collection("accounts").updateOne({_id:new a.ObjectId(o.accountId)},{$inc:{balance:c},$set:{updatedAt:new Date}},{session:i})}}}}};